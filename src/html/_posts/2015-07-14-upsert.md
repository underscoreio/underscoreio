---
layout: post
title: Upsert in Slick 3
author: Richard Dallaway
---

An _upsert_ means inserting a row into a database if it doesn't already exist,
or updating the row if it does exist. The [Slick] database library knows how to do upserts.
This posts takes a look at the built-in support,
and gives an example of what you can do if you need to roll your own upsert logic.

_This is part of a series on Slick, for material in or being added to [Essential Slick]_.

[Essential Slick]: http://underscore.io/training/courses/essential-slick/
[Github project]: https://github.com/d6y/slick-upsert
[Slick]: http://slick.typesafe.com/

<!-- break -->

## Built in Support

In Slick an upsert is provided by the method `insertOrUpdate`. If you have a table and a representation of a row you can `insertOrUpdate` that row. Very convenient.

This means two things:

- Slick will do whatever it needs to do to bring about the equivalent of an `INSERT` or `UPDATE` for you.  I'm being vague here, because "what it needs to do" could well vary depending on the database product you are using.
- Slick needs a way to match the value you have to some row in the database. The usual way to do that is with a primary key (composite or otherwise).

An example will make this clearer. Let's say we're running a movie reviews database.  We have film titles with a rating.
In Slick we might model rows with a `Review` case class for the `ReviewTable`:

~~~ scala
final case class Review(title: String, rating: Int, id: Long = 0L)

// Hello to Jason Isaacs
final class ReviewTable(tag: Tag) extends Table[Review](tag, "review") {
  def id      = column[Long]("id", O.PrimaryKey, O.AutoInc)
  def title   = column[String]("content")
  def rating  = column[Int]("rating")
  def * = (title, rating, id) <> (Review.tupled, Review.unapply)
}

val reviews = TableQuery[ReviewTable]
~~~

We can conjure up some reviews, and construct a program that will create the database, populate it, and give us back the content:

~~~ scala
val testData = Seq(
  Review("Godzilla", 8),
  Review("Godzilla Raids Again", 6),
  Review("King Kong vs. Godzilla", 5)
)

val action = for {
  _     <- reviews.schema.create
  _     <- reviews ++= testData
  films <- reviews.result
} yield films
~~~

If you're not familiar with Slick 3, you don't need to worry about the details above too much.
The key point is that Slick works by handing an _acitons_ (such as `DBIO[T]`) to the database to be run,
returning you a `Future[T]` of the result.

Let's run the above:

~~~ scala
val future = db.run(action).map { _ foreach println }
Await.result(future, 2 seconds)
// Output:
// Review(Godzilla,8,1)
// Review(Godzilla Raids Again,6,2)
// Review(King Kong vs. Godzilla,5,3)  
~~~

Because we're selecting all film reviews, we end up with a `Future[Seq[Review]]` this time.
But for the rest of this post we are dealing with inserting and updating. By default we'll get back a count of affected rows.
This means the results we will work with are going to be `Future[Int]`.

So I want to post a new review. Maybe I'll have changed my mind about a rating. Or maybe I'm reviewing a new film. What's the code look like?

~~~ scala
def postReview(title: String, rating: Int): DBIO[Int] = for {
  existing <- reviews.filter(_.title === title).result.headOption
  row       = existing.map(_.copy(rating=rating)) getOrElse Review(title, rating)
  result   <- reviews.insertOrUpdate(row)
} yield result
~~~

This code will take a film title and rating, and either insert a new row, or update an existing row. It returns a count of the rows affected, as a `DBIO[Int]`. This action is what we will run later.

Let's walk down the body of this method:

- We lookup a film by title. The `review.filter` is a query, which we turn into the action we want via `result.headOption`  This will give us an `Option[Review]`.

- We're going to either use the row we found and modify the rating via a copy constructor; or we're going to construct a new row.

- Finally, we hand the row to `insertOrUpdate`, also a `DBIO[Int]`, which will do "the right thing" when we `run` it.

In the case of H2, "the right thing" is either this sequence of SQL if it is an existing row...

~~~ sql
select 1 from "review" where "id"=?
update "review" set "title"=?,"rating"=? where "id"=?
~~~

...or this SQL if it's a new row:

~~~ sql
select 1 from "review" where "id"=?
insert into "review" ("title","rating") values (?,?)
~~~

Notice that Slick is using the primary key, `id`, to check and update the row.

That's reasonably straight-forward. The right effect occurs in the database, and you get back a count of rows changed.

Sometimes you want the row back, not the count. Slick supports that via `returning`.
We discuss `returning` in Chapter 2 of [Essential Slick], but the pattern is:

~~~ scala
(reviews returning reviews).insertOrUpdate(row)
~~~

Not all database products support that.

## Rolling Our Own Update

By included `insertOrUpdate` I'm guessing the Slick team have covered a large percentage of use cases for upsert. But if you want to do something different, how can you get the logic you need mixed in with database actions?

Let's look at a slight variation of our film reviews database:

~~~ scala
final case class Review(critic: String, title: String, rating: Int)

final class ReviewTable(tag: Tag) extends Table[Review](tag, "review") {
  def critic = column[String]("critic_name")
  def title  = column[String]("title")
  def rating = column[Int]("rating")
  def * = (critic, title, rating) <> (Review.tupled, Review.unapply)
}
~~~

We're not using a primary key here. We're going to use this to exercise custom logic over what we do when posting a review.
(And it is just an illustration: you could, and probably should, use a composite key here. I've included an example of that in the [source code][Github project] that goes with this post.)

Without a key `insertOrUpdate` won't work for us. We can try a different approach. Let's asume we're mostly making edits, and an update to a rating will probably succeed. If it doesn't, we'll try an insert.

We need something like this:

~~~ scala
def postReview(critic: String, title: String, rating: Int): DBIO[Int] = {
  for {
    rowsAffected <- reviews.
                     filter(r => r.critic === critic && r.title === title).
                     map(_.rating).
                     update(rating)
    ???
    }
  } yield ???
}
~~~

We start with a query for existing reviews by this critic for the film with the particular title we care about.  We turn into into a `DBIO[Int]` because it is an `update` of the `rating`. This will give us the rows affected by the update.

The logic we now want is:

- if there are no rows affected, we need to insert a new review
- if there was one row affected, we're done!
- otherwise, something really bad has happened and we have multiple reviews for a film by the same critic. This cannot be allowed to stand.

We're able to achieve this because of a key feature of Slick 3: `DBIO` actions compose. If you're approaching this thinking "how can I get the count out of the `DBIO`", don't.  Instead, think about what you can do to combine `DBIO`s together.

What we need to complete `postReview` is another `DBIO`. There are several ways we can get one. Calling `result` on a query is one way, but there are also standard ways to construct a `DBIO` for success and failure cases.  We can use them to complete the code:

~~~ scala
def postReview(critic: String, title: String, rating: Int)
              (implicit ec: ExecutionContext): DBIO[Int] = {
  for {
    rowsAffected <- reviews.filter(r => r.critic === critic && r.title === title).
                    map(_.rating).update(rating)
    result <- rowsAffected match {
      case 0 => reviews += Review(critic, title, rating)
      case 1 => DBIO.successful(1)
      case n => DBIO.failed(new RuntimeException(
                s"Expected 0 or 1 change, not $n for $critic @ $title"))
    }
  } yield result
}
~~~

As an exercise, you can de-sugar that for comprehension into `flatMap` and `map` to dig into what's going on.  The main thing to notice, though, is the right-hand side of those case patterns are producing `DBIO[Int]`s.  One is via an insert, one via a constant, and one via signalling failure.

Because we're mixing database queries and user logic here in the for comprehension, we need to also have an `ExecutionContext` in scope. Our logic will run on the context we supply to the method.

## Conclusions

Slick contains a convenient way to upsert database records, based on the availability of a primary key.  

But it is not limited to just that.  You can combine _database actions_ together, mixing in your own custom logic.

There's a [Github project] where you can try the code out.  This example is likely to appear in the upcoming revisions to [Essential Slick].
